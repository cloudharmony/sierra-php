<?php
{if $headerTemplate}{$Template->display($headerTemplate)}


{/if}
// {ldelim}{ldelim}{ldelim} Header
/*
 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
 | SIERRA : PHP Application Framework  http://code.google.com/p/sierra-php |
 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
 |                   *** DO NOT EDIT THIS FILE ***                         |
 |                                                                         |
 | This dtd source file was generated by the SIERRA Entity modeler.        |
 | according to the entity model described in the source file listed below.|
 | This file will be overwritten each time a change to that file is made.  |
 +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
 entity model source file: {$entityModelPath}
 */
// {rdelim}{rdelim}{rdelim}
{assign var="aopClassType", $smarty.const.SRA_AOP_CLASS_DAO}
// {ldelim}{ldelim}{ldelim} Imports
require_once('model/SRA_WS.php');
require_once('model/SRA_WSRequest.php');
{if $entity->_daoExtendsFile}
require_once({$entity->getIncludePath($entity->_daoExtendsFile)});
{/if}

{foreach from=$includes item=include}
require_once('{$include}');
{/foreach}
// {rdelim}{rdelim}{rdelim}

// {ldelim}{ldelim}{ldelim} Constants
  // aop constants
{foreach from=$entity->getAopIntroductions($smarty.const.SRA_AOP_INTRODUCTION_TYPE_CONSTANT, $aopClassType) item=introduction}
  define('{$introduction->getValue(0)}', {$introduction->getValue(1)});
{/foreach}
// {rdelim}{rdelim}{rdelim}

// {ldelim}{ldelim}{ldelim} {$className}
/**
 * This Data Access Object (DAO) was generated from the definition specified in 
 * {$entity->_entityModelXml}
 * It will be overwritten every time a change to that file is made
 * 
 * {if $entity->_apiResource}{$resources->getString($entity->_apiResource)}{else}{$resources->getString($entity->_resource)}{/if}

 * 
 */
class {$className}{if $entity->_daoExtends} extends {$entity->_daoExtends}{/if} {ldelim}
  // {ldelim}{ldelim}{ldelim} Attributes
  
  // private attributes
  /**
   * used to store cached instances of all posts retrieved through the finder 
   * methods
   * @type array
   * @access private
   */
  var $_cached = array();
  
  /**
   * the SRA_Util::parseUri value for $_wsDb. refreshed whenever validateWsDb is 
   * invoked
   * @type array
   * @access private
   */
  var $_parsedWsDb;
  
  /**
   * the URI to the web service host
   * @type string
   * @access private
   */
  var $_wsDb = '{$entity->_wsDb}';
  
  /**
   * the name of the web service on $_wsDb providing CRUD capabilities for this 
   * entity
   * @type string
   * @access private
   */
  var $_wsDbName = '{$entity->_wsDbName}';
  
  /**
   * used to keep track of current ws db sessions (hash indexed by wsDb URI)
   * @type string
   * @access hash
   */
  var $_wsDbSessions = array();
  
  
  // aop attributes
{foreach from=$entity->getAopIntroductions($smarty.const.SRA_AOP_INTRODUCTION_TYPE_ATTRIBUTE, $aopClassType) item=introduction}
  var ${$introduction->getValue()};
{/foreach}
  
  // {rdelim}{rdelim}{rdelim}
  
  // {ldelim}{ldelim}{ldelim} Operations
  
  // constructor
  // {ldelim}{ldelim}{ldelim} {$className}
  /**
   * {$className} constructor. this class should only be instantiated by the 
   * SRA_DaoFactory
   * @access  package
   */
  function {$className}() {ldelim} 
    {assign var='aopMethodName', $className}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // public methods
  
  
  // {ldelim}{ldelim}{ldelim} delete
  /**
   * This method is used to delete an existing {$entity->_name} object
   * @param {$voClassName} $record The {$entity->_name} instance to delete
   
   * @access public
   * @return void
   */
  function delete(& $record) {ldelim}
    {assign var='aopMethodName', "delete"}
    {include file="entity-aspect-before.tpl"}
    static $deletingRecord = array();
    
    // check if param is a valid {$voClassName} instance
    if (!{$voClassName}::isValid($record)) {ldelim}
      $msg = "{$className}::delete: Failed - parameter is not a valid {$voClassName} instance";
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // validate deletion for {$voClassName}
    if (!$record->validateDelete()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::delete: Failed - {$voClassName} deletion validation failed: " . implode(', ', $record->validateErrors);
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // validate primary key
    if (!$record->getPrimaryKey()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return FALSE;
    {rdelim}

    // does record already exist
    if (!$record->recordExists) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return FALSE; 
    {rdelim}
    
    // avoid recursive looping
    if ($deletingRecord[$record->getPrimaryKey()]) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return FALSE;
    {rdelim}
    
    $deleteRecordId = $record->getPrimaryKey();
    $deletingRecord[$deleteRecordId] = TRUE;
    
    // all ok, continue with deletion
    // TODO
    
    $deletingRecord[$deleteRecordId] = FALSE;
    
    $deleted = TRUE;
    {include file="entity-aspect-after.tpl"}
    
    return $deleted;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} findAll
  /**
   * Used to return all of the {$entity->_name} instances
   * @param int $limit the max # of records to return
   * @param int $offset the first record (where 0 is the first row) to begin 
   * considering
   * @access public
   * @return {$voClassName}[]
   */
  function &findAll($limit=NULL, $offset=NULL) {ldelim}
    {assign var='aopMethodName', "findAll"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return $this->findByConstraints(array(), $limit, $offset);
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} findByConstraints
  /**
   * Used to return all of the {$entity->_name} records that have matching attr 
   * values. all attributes must be scalar and stored in the primary entity 
   * table
   * @param array $constraints attr/value pairs to match. alternatively, this 
   * may be a pre-populated web services constraints hash. for more info, see 
   * the documentation provided in sra-ws-gateway.php for constructing 
   * constraint parameters for web service invocations
   * @param int $limit the max # of records to return
   * @param int $offset the first record (where 0 is the first row) to begin 
   * considering
   * @param string $connective the connective to use between contraints (either 
   * 'or' or 'and') - default is 'and'
   * @param int $operator the comparison operator to use. default is 1 or equals
   * see ws-request.dtd - ws-constraint - operator for more info
   * @access public
   * @return {$voClassName}[]
   */
  function &findByConstraints($constraints, $limit=NULL, $offset=NULL, $connective = 'and', $operator = 1) {ldelim}
    {assign var='aopMethodName', "findByConstraints"}
    {include file="entity-aspect-before.tpl"}
    
    // check if param is a valid {$voClassName} instance
    if (!is_array($constraints)) {ldelim}
      $msg = "{$className}::findByConstraints: Failed - constraints must be an array with 1 or more column/value pairs";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // check if $constraints is already a pre-populated web services constraints hash
    foreach($constraints as $attr => $val) {ldelim}
      if (SRA_Util::beginsWith($attr, 'ws-')) {ldelim}
        $params = $constraints;
        break;
      {rdelim}
    {rdelim}
    
    // construct web service invocation parameters
    if (!$params) {ldelim}
      $params = array('ws-constraint1-connective' => $connective);
      foreach($constraints as $attr => $val) {ldelim}
        $params['ws-constraint1-attr' . $i] = $attr;
        $params['ws-constraint1-value' . $i] = $val;
        $params['ws-constraint1-operator' . $i] = $operator;
      {rdelim}
    {rdelim}
    
    if (!is_object($results =& $this->_invokeWs($params, $limit, $offset)) || !isset($results->status)) {ldelim}
      $msg = "{$className}::findByConstraints: Failed - Unable to invoke web service";
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    $records = NULL;
    if ($results->status == SRA_WS_REQUEST_STATUS_SUCCESS) {ldelim}
      $records = array();
      if (is_array($results->response)) {ldelim}
        foreach(array_keys($results->response) as $key) {ldelim}
          $records[] =& $this->_responseToObj($results->response[$key]);
        {rdelim}
      {rdelim}
    {rdelim}
    else {ldelim}
      $msg = '{$className}::findByConstraints: Failed - Unable to invoke web service, status returned was: "' . $results->status . '"';
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    if ($records) {ldelim}
      foreach(array_keys($records) as $key) {ldelim}
        $this->_cached[$records[$key]->getPrimaryKey()] =& $records[$key];
      {rdelim}
    {rdelim}
    
    {include file="entity-aspect-after.tpl"}
    return $records;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} findByPk
  /**
   * This method is used to lookup an existing {$entity->_name} object based on 
   * a primary key value
   * @param {$primaryKey->_type} $id the primary key of the {$entity->_name} object to return
   * @param boolean $reload whether or not to ignore any cached versions of the 
   * object
   * @access public
   * @return {$voClassName}
   */
  function &findByPk($id, $reload=FALSE) {ldelim}
    {assign var='aopMethodName', "findByPk"}
    {include file="entity-aspect-before.tpl"}
    
    // check for cached
    if (!$reload && $id && isset($this->_cached[$id])) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return $this->_cached[$id];
    {rdelim}
    
    // check if id is valid
    if (!$id || !is_scalar($id)) {ldelim}
      $msg = "{$className}::findByPk: Failed - No id specified or is not scalar: Type - " . gettype($id) . " Value - " . $id;
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    if (!is_object($results =& $this->_invokeWs(array('ws-id' => $id))) || !isset($results->status)) {ldelim}
      $msg = "{$className}::findByPk: Failed - Unable to invoke web service";
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    $record = NULL;
    if ($results->status == SRA_WS_REQUEST_STATUS_SUCCESS && is_object($results->response)) {ldelim}
      $record =& $this->_responseToObj($results->response);
    {rdelim}
    else if ($results->status != SRA_WS_REQUEST_STATUS_INVALID_PK) {ldelim}
      $msg = '{$className}::findByPk: Failed - Unable to invoke web service, status returned was: "' . $results->status . '"';
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    if ($record) {ldelim}
      $this->_cached[$record->getPrimaryKey()] =& $record;
    {rdelim}
    
    {include file="entity-aspect-after.tpl"}
    return $record;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} findByPks
  /**
   * Returns all of the {$entity->_name} records with ids matching those 
   * specified in the ids parameter
   * 
   * @param int[] $ids the primary key values of the {$entity->_name} records to 
   * return. if this parameter is a SRA_ResultSet object, then the ids will be 
   * extracted from the 1st element of each row in those results.
   * @param int $limit the max # of records to return
   * @param int $offset the first record (where 0 is the first row) to begin 
   * considering
   * @param boolean $reload whether or not to ignore any cached versions of the 
   * object
   * @access public
   * @return {$voClassName}[]
   */
  function &findByPks($ids, $limit=NULL, $offset=NULL, $reload=FALSE) {ldelim}
    {assign var='aopMethodName', "findByPks"}
    {include file="entity-aspect-before.tpl"}
    
    $records = array();
    $constraints = array();
    foreach($ids as $i => $id) {ldelim}
      if (!$reload && isset($this->_cached[$id])) {ldelim}
        $records[$id] =& $this->_cached[$id];
      {rdelim}
      else {ldelim}
        $constraints['{$primaryKey->_name}'] = $id;
      {rdelim}
    {rdelim}
    
    if (count($constraints)) {ldelim}
      $crecords =& $this->findByConstraints($constraints, $limit, $offset, 'or');
    {rdelim}
    
    foreach(array_keys($crecords) as $key) {ldelim}
      $records[$key] =& $crecords[$key];
    {rdelim}
    
    {include file="entity-aspect-after.tpl"}
    return $records;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} getPkName
  /**
   * This method returns the name of the primary key for the entity managed by 
   * this DAO.
   * @access public
   * @return string
   */
  function getPkName() {ldelim}
    {assign var='aopMethodName', "getPkName"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return '{$primaryKey->_name}';
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} getPkType
  /**
   * This method returns the database type for the primary key of the entity 
   * managed by this DAO. This value will correspond with one of the SRA_Database 
   * class type constants
   * @access public
   * @return string
   */
  function getPkType() {ldelim}
    {assign var='aopMethodName', "getPkType"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return '{$primaryKey->_type}';
  {rdelim}
  // {rdelim}{rdelim}{rdelim}


{foreach from=$entity->getAttributes() item=attribute}
{if $attribute->_lazyLoad}
{assign var="methodName" value="get"|cat:$attribute->getMethodName()}

  // {ldelim}{ldelim}{ldelim} {$methodName}
  /**
   * This method returns the {$attribute->_name} attribute for a given {$entity->_name}
   * @param {$entity->_type} $record the {$entity->_type} instance to return the 
   * {$attribute->_name} for
{if $attribute->_cardinality && $attribute->isEntity() && !$attribute->isEntitySkipPersistence()}
   * @param mixed $pk if only a single {$attribute->_name} should be returned, 
   * this parameter may be specified as the primary key of that object
{/if}
   * @access public
   * @return {$attribute->_type}{if $attribute->_cardinalityUpper > 1}[]{/if}

   */
  function {if $attribute->_useReference}&{/if}{$methodName}(& $record{if $attribute->_cardinality && $attribute->isEntity() && !$attribute->isEntitySkipPersistence()}, $pk = FALSE{/if}) {ldelim}
    
    {assign var='aopMethodName', $methodName}
    {include file="entity-aspect-before.tpl"}
    
{if $attribute->_cardinality && $attribute->isEntity() && !$attribute->isEntitySkipPersistence()}
    if ($pk) {ldelim}
      $dao =& SRA_DaoFactory::getDao('{$attribute->_type}');
      {include file="entity-aspect-after.tpl"}
      return $dao->findByPk($pk);
    {rdelim}
    else {ldelim}
{/if}
    $attrs = NULL;
    if (!is_object($results =& $this->_invokeWs(array('ws-id' => $record->getPrimaryKey(), 'ws-include' => '{$attribute->_name}{if $attribute->isEntity() && !$attribute->isEntitySkipPersistence()}_{$attribute->getEntityPkName()}{/if}'))) || !isset($results->status)) {ldelim}
      $msg = "{$className}::{$methodName}: Failed - Unable to invoke web service";
      SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    else if ($results->status == SRA_WS_REQUEST_STATUS_SUCCESS && is_object($results->response)) {ldelim}
      $attrs =& $results->response->{$attribute->_name};
{if $attribute->_isFile}
{if $attribute->_cardinality}
      foreach(array_keys($attrs) as $key) {ldelim}
{/if}
      if (!($attrs{if $attribute->_cardinality}[$key]{/if} =& $this->_convertFileAttr($attrs{if $attribute->_cardinality}[$key]{/if}))) unset($attrs{if $attribute->_cardinality}[$key]{/if});
{if $attribute->_cardinality}
      {rdelim}
{/if}
{/if}

{if $attribute->isEntity()}
      $attrs = SRA_Util::objToHash($attrs);
{if !$attribute->isEntitySkipPersistence()}
      $dao =& SRA_DaoFactory::getDao('{$attribute->_type}');
{if $attribute->_cardinality}
      $pks = array();
{/if}
{/if}
{if $attribute->_cardinality}
      foreach(array_keys($attrs) as $key) {ldelim}
{/if}
{if $attribute->isEntitySkipPersistence()}
      $attrs{if $attribute->_cardinality}[$key]{/if} = new {$attribute->_type}{$entity->_voSuffix}($attrs[$key], FALSE, TRUE);
{else}
{if $attribute->_cardinality}
      $pks[] = $attrs[$key]['{$attribute->getEntityPkName()}'];
{else}
      $attrs =& $dao->findByPk($attrs['{$attribute->getEntityPkName()}']);
{/if}
{/if}
{if $attribute->_cardinality}
      {rdelim}
{if !$attribute->isEntitySkipPersistence()}
      if ($pks) {ldelim}
        $attrs =& $dao->findByPks($pks);
      {rdelim}
      else {ldelim}
        $attrs = NULL;
      {rdelim}
{/if}
{/if}
{/if}
    {rdelim}
    else {ldelim}
      $msg = '{$className}::{$methodName}: Failed - Unable to invoke web service, status returned was: "' . $results->status . '"';
      SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
{if $attribute->_cardinality && $attribute->isEntity() && !$attribute->isEntitySkipPersistence()}
    {rdelim}
{/if}
    
    {include file="entity-aspect-after.tpl"}
    
    return $attrs;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
{/if}
{/foreach}
  
  
  // {ldelim}{ldelim}{ldelim} insert
  /**
   * This method is used to insert a new {$entity->_name} object into the 
   * persistency store managed by this DAO. If the {$entity->_name} uses an 
   * auto-sequence primary key, then the value of that primary key will be 
   * auto-set in the referenced {$voClassName} parameter. If the $record already 
   * exists, the update method will be invoked instead
   * @param {$voClassName} $record The {$entity->_name} instance to insert
   * @access public
   * @return void
   */
  function insert(& $record) {ldelim}
    {assign var='aopMethodName', "insert"}
    {include file="entity-aspect-before.tpl"}
    // check if param is a valid {$voClassName} instance
    if (!{$voClassName}::isValid($record)) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::insert: Failed - parameter is not a valid {$voClassName} instance";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // does record already exist? if it does, pass to the update method
    if ($record->recordExists) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return $this->update($record, $insertSubEntities);    
    {rdelim}
    
    // validate {$voClassName}
    if (!$record->validate()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::insert: Failed - {$voClassName} instance validation failed: " . implode(', ', $record->validateErrors);
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
{if $primaryKey->_sequence}
    // validate primary key - cannot be set because it is a sequence
    if ($record->getPrimaryKey()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::insert: Failed - Primary key " . $record->getPrimaryKey() . " already set for sequence. Object cannot be inserted";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
{else}
    // validate primary key - must be set because it is not an auto-sequence
    if (!$record->getPrimaryKey()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::insert: Failed - No primary key specified for this {$voClassName}";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
{/if}
    
    // TODO
    
    $oldDirtyFlags = $record->_dirty;
    $inserted = TRUE;
    $record->resetDirtyFlags({if $entity->_fileHandling eq $smarty.const.SRA_FILE_ATTRIBUTE_TYPE_DB}array({foreach from=$entity->getAttributes() item=attribute}{if $attribute->_isFile && !$attribute->_cardinality}'{$attribute->_name}', {/if}{/foreach}){/if});
    
{if $entity->_fileHandling eq $smarty.const.SRA_FILE_ATTRIBUTE_TYPE_DB}
{foreach from=$entity->getAttributes() item=attribute}
{if $attribute->_isFile && !$attribute->_cardinality}
    if ($record->isDirty('{$attribute->_name}') && SRA_FileAttribute::isValid($record->getAttribute('{$attribute->_name}'))) {ldelim}
        $record->_{$attribute->_name}->_setEntityId($record->getPrimaryKey());
{if $attribute->_fileUriAttr && $entity->hasAttribute($attribute->_fileUriAttr)}
        // set file uri to the {$attribute->_fileUriAttr} attribute
        $record->setAttribute('{$attribute->_fileUriAttr}', $record->_{$attribute->_name}->getUri());
{/if} {* $attribute->_fileUriAttr && $entity->hasAttribute($attribute->_fileUriAttr) *}
    {rdelim}
{/if}
{/foreach}
    if ($record->isDirty()) {ldelim} $this->update($record); {rdelim}
{/if}

    {include file="entity-aspect-after.tpl"}
    return $inserted;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} newInstance
  /**
   * returns a new instance of a {$entity->_name}{$entity->_voSuffix} object
   * 
   * @param array $params any initialization params (optional)
   * @access public
   * @return void
   */
  function &newInstance($params=NULL) {ldelim}
    {assign var='aopMethodName', "newInstance"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return new {$entity->_name}{$entity->_voSuffix}($params);
  {rdelim}
  // {rdelim}{rdelim}{rdelim}

  
  // {ldelim}{ldelim}{ldelim} update
  /**
   * This method is used to update an existing {$entity->_name} object in the 
   * persistency store managed by this DAO. . If the $record does not exist, the 
   * insert method will be invoked instead. returns TRUE if an update was 
   * necessary and performed. FALSE if an update was not necessary because the 
   * $record was not dirty
   * @param {$voClassName} $record The {$entity->_name} instance to update.
   * @access public
   * @return boolean
   */
  function update(& $record) {ldelim}
    {assign var='aopMethodName', "update"}
    {include file="entity-aspect-before.tpl"}
    // check if param is a valid {$voClassName} instance
    if (!{$voClassName}::isValid($record)) {ldelim}
      $msg = "{$className}::update: Failed - parameter is not a valid {$voClassName} instance";
      {include file="entity-aspect-after.tpl"}
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // does record not exist? if it does not, pass to the insert method
    if (!$record->recordExists) {ldelim}
      {include file="entity-aspect-after.tpl"}
      return $this->insert($record);    
    {rdelim}
    
    // validate {$voClassName}
    if (!$record->validate()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::update: Failed - {$voClassName} instance validation failed: " . implode(', ', $record->validateErrors);
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // validate primary key - must be set
    if (!$record->getPrimaryKey()) {ldelim}
      {include file="entity-aspect-after.tpl"}
      $msg = "{$className}::update: Failed - No primary key specified for this {$voClassName}";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    
    // TODO
    
    $oldDirtyFlags = $record->_dirty;
    $updated = TRUE;
    $record->resetDirtyFlags();
    
    {include file="entity-aspect-after.tpl"}
    return $updated;
    
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} reload
  /**
   * reloads the given {$entity->_name} object with the current data for that 
   * object in the database
   * @param ${$entity->_name} the object to reload. must exist in the database
   * @access public
   * @return {$entity->_name}{$entity->_voSuffix}
   */
  function &reload(& ${$entity->_name}) {ldelim}
    {assign var='aopMethodName', "reload"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return $this->findByPk(${$entity->_name}->getPrimaryKey(), TRUE);
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} toString
  /**
   * Returns a string representation of this object
   * @access public
   * @return String
   */
  function toString() {ldelim}
    {assign var='aopMethodName', "toString"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return SRA_Util::objectToString($this);
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} getWsDb
  /**
   * returns the ws-db currently in use by this dao
   * @access public
   * @return string
   */
  function getWsDb() {ldelim}
    {assign var='aopMethodName', "getWsDb"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return $this->_wsDb;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} getWsDbName
  /**
   * returns the ws-db-name currently in use by this dao
   * @access public
   * @return string
   */
  function getWsDbName() {ldelim}
    {assign var='aopMethodName', "getWsDbName"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return $this->_wsDbName;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} setWsDb
  /**
   * sets the ws-db to use by this dao
   * @param string $wsDb the web service db URI to use (see entity-model.dtd 
   * documentation for the ws-db attribute for more info)
   * @access public
   * @return string
   */
  function setWsDb($wsDb) {ldelim}
    {assign var='aopMethodName', "setWsDb"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    $this->_wsDb = $wsDb;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} setWsDbName
  /**
   * sets the ws-db-name to use by this dao
   * @param string $wsDbName the web service name to use (see entity-model.dtd 
   * documentation for the ws-db-name attribute for more info)
   * @access public
   * @return string
   */
  function setWsDbName($wsDbName) {ldelim}
    {assign var='aopMethodName', "setWsDbName"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    $this->_wsDbName = $wsDbName;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} validateWsDb
  /**
   * returns TRUE if the web service DB URI is valid
   * @access public
   * @return boolean
   */
  function validateWsDb() {ldelim}
    {assign var='aopMethodName', "validateWsDb"}
    {include file="entity-aspect-before.tpl"}
    $this->_parsedWsDb = SRA_Util::parseUri($this->_wsDb);
    {include file="entity-aspect-after.tpl"}
    return $this->_parsedWsDb ? TRUE : FALSE;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // private operations
  
  // {ldelim}{ldelim}{ldelim} _convertFileAttr
  /**
   * converts a file attribute hash to an SRA_FileAttribute instance
   * @param object $attr the attribute to convert
   * @access private
   * @return SRA_FileAttribute
   */
  function &_convertFileAttr($attr) {ldelim}
    if (is_object($attr)) $attr = SRA_Util::objToHash($attr);
    if (is_array($attr) && isset($attr['name']) && isset($attr['size']) && isset($attr['type']) && isset($attr['uri'])) {ldelim}
      $uri = $this->_getBaseUri() . $attr['uri'];
      $attr = new SRA_FileAttribute(NULL, $attr['name'], $attr['size']*1, $attr['type']);
      $attr->setHardPath($uri);
    {rdelim}
    else {ldelim}
      $attr = NULL;
    {rdelim}
    return $attr;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} _getBaseUri
  /**
   * returns the base URI for the wsDb
   * @access private
   * @return string
   */
  function _getBaseUri() {ldelim}
    $uri = NULL;
    if ($this->_parsedWsDb) {ldelim}
      $uri = $this->_parsedWsDb['protocol'] . '://';
      if ($this->_parsedWsDb['user']) $uri .= $this->_parsedWsDb['user'];
      if ($this->_parsedWsDb['user'] && $this->_parsedWsDb['pswd']) $uri .= ':' . $this->_parsedWsDb['pswd'];
      if ($this->_parsedWsDb['user'] || $this->_parsedWsDb['pswd']) $uri .= '@';
      $uri .= $this->_parsedWsDb['host'];
      if ($this->_parsedWsDb['port']) $uri .= ':' . $this->_parsedWsDb['port'];
    {rdelim}
    return $uri;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} _getWsIncludeParam
  /**
   * returns the value to use for the ws-include parameter (only non-lazy load 
   * attributes are included)
   * @access private
   * @return string
   */
  function _getWsIncludeParam() {ldelim}
    $wsInclude = '';
{foreach from=$entity->getAttributes() item=attribute}
{if !$attribute->_lazyLoad}
    $wsInclude .= ($wsInclude ? ',' : '') . '{$attribute->_name}';
{/if}
{/foreach}
    return $wsInclude ? $wsInclude : NULL;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} _invokeWs
  /**
   * invokes the web service for this entity and returns the json decoded 
   * response when successful, NULL otherwise (error will be logged if not 
   * successful). validateWsDb should be invoked prior to this method
   * @param hash $params optional web service parameters to apply to the 
   * invocation
   * @param int $limit an optional invocation limit
   * @param int $offset an optional invocation offset
   * @access private
   * @return mixed
   */
  function &_invokeWs($params=NULL, $limit=NULL, $offset=NULL) {ldelim}
    $results = NULL;
    if (!function_exists('curl_init') || !function_exists('json_decode')) {ldelim}
      $msg = '{$className}::_invokeWs: Failed - curl or json extension is not installed';
      SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    else if (!$this->_wsDbName) {ldelim}
      $msg = "{$className}::_invokeWs: Failed - No web service name has been specified";
      return SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    else if (!$this->validateWsDb()) {ldelim}
      $msg = "{$className}::_invokeWs: Failed - The web service URI '" . $this->_wsDb . "' is not valid";
      SRA_Error::logError($msg, __FILE__, __LINE__);
    {rdelim}
    else {ldelim}
      if (!$params) $params = array();
      $params['ws'] = $this->_wsDbName;
      if (!isset($params['ws-exclude']) && !isset($params['ws-include']) && ($wsInclude = $this->_getWsIncludeParam())) $params['ws-include'] = $wsInclude;
      if ($this->_parsedWsDb['params']) $params = array_merge($params, $this->_parsedWsDb['params']);
      if ($this->_parsedWsDb['user']) $params['ws-user'] = $this->_parsedWsDb['user'];
      if ($this->_parsedWsDb['pswd']) $params['ws-password'] = $this->_parsedWsDb['pswd'];
      $params['ws-date-format'] = SRA_GREGORIAN_DATE_FORMAT_ISO8601;
      $params['ws-time-format'] = SRA_GREGORIAN_DATE_FORMAT_ISO8601;
      $params['ws-format'] = SRA_WS_FORMAT_JSON;
      $params['ws-use-sessions'] = TRUE;
      if (isset($this->_wsDbSessions)) $params['ws-session-id'] = $this->_wsDbSessions[$this->_wsDb];
      if ($limit) $params['ws-limit'] = $limit;
      if ($offset) $params['ws-offset'] = $offset;
      $url = $this->_parsedWsDb['protocol'] . '://' . $this->_parsedWsDb['host'] . ($this->_parsedWsDb['port'] ? ':' . $this->_parsedWsDb['port'] : '') . ($this->_parsedWsDb['path'] ? $this->_parsedWsDb['path'] : '');
      if ($ch = curl_init($url)) {ldelim}
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $params);
        ob_start();
        if (curl_exec($ch)) {ldelim}
          $results =& json_decode(ob_get_clean());
          if (is_object($results) && isset($results->sessionId)) $this->_wsDbSessions[$this->_wsDb] = $results->sessionId;
          return $results;
        {rdelim}
        else {ldelim}
          $msg = '{$className}::_invokeWs: Failed - URL ' . $url . ' could not be processed';
          SRA_Error::logError($msg, __FILE__, __LINE__);
        {rdelim}
        ob_end_clean();
        curl_close($ch);
      {rdelim}
      else {ldelim}
        $msg = '{$className}::_invokeWs: Failed - URL ' . $url . ' could not be opened';
        SRA_Error::logError($msg, __FILE__, __LINE__);
      {rdelim}
    {rdelim}
    
    return $results;
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // {ldelim}{ldelim}{ldelim} _responseToObj
  /**
   * converts a web service json response object to a {$voClassName} object
   * @param object $response the web service json response object
   * @access private
   * @return {$voClassName}
   */
  function &_responseToObj(&$response) {ldelim}
    $initVals = array();
{foreach from=$entity->getAttributes() item=attribute}
    if (isset($response->{$attribute->_name})) {ldelim}
{if $attribute->_isFile}
      $response->{$attribute->_name} =& $this->_convertFileAttr($response->{$attribute->_name});
{/if}
      $initVals['{$attribute->_name}'] =& $response->{$attribute->_name};
    {rdelim}
{/foreach}
    return new {$voClassName}($initVals, FALSE, TRUE);
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
  
  
  // public static methods
  
  // {ldelim}{ldelim}{ldelim} isValid()
  /**
   * Static method that returns true if the object parameter is a {$className} object.
   *
   * @param  Object $object The object to validate
   * @access public
   * @return  boolean
   */
  function isValid( & $object ) {ldelim}
    {assign var='aopMethodName', "isValid"}
    {include file="entity-aspect-before.tpl"}
    {include file="entity-aspect-after.tpl"}
    return (is_object($object) && (!isset($object->err) || !SRA_Error::isError($object->err)) && strtolower(get_class($object)) == '{$className|lower}' || is_subclass_of($object, '{$className|lower}'));
  {rdelim}
  // {rdelim}{rdelim}{rdelim}

  
  // aop methods
{foreach from=$entity->getAopIntroductions($smarty.const.SRA_AOP_INTRODUCTION_TYPE_METHOD, $aopClassType) item=introduction}
  // {ldelim}{ldelim}{ldelim} {$introduction->getValue()}
  function {$introduction->getValue()} {ldelim}
    {$introduction->getCode()}
  {rdelim}
  // {rdelim}{rdelim}{rdelim}
{/foreach}

  
{rdelim}
// {rdelim}{rdelim}{rdelim}
?>
